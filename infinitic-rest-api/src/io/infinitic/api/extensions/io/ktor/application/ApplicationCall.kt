/**
 * "Commons Clause" License Condition v1.0
 *
 * The Software is provided to you by the Licensor under the License, as defined
 * below, subject to the following condition.
 *
 * Without limiting other conditions in the License, the grant of rights under the
 * License will not include, and the License does not grant to you, the right to
 * Sell the Software.
 *
 * For purposes of the foregoing, “Sell” means practicing any or all of the rights
 * granted to you under the License to provide to third parties, for a fee or
 * other consideration (including without limitation fees for hosting or
 * consulting/ support services related to the Software), a product or service
 * whose value derives, entirely or substantially, from the functionality of the
 * Software. Any license notice or attribution required by the License must also
 * include this Commons Clause License Condition notice.
 *
 * Software: Infinitic
 *
 * License: MIT License (https://opensource.org/licenses/MIT)
 *
 * Licensor: infinitic.io
 */

package io.infinitic.api.extensions.io.ktor.application

import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper
import io.ktor.application.ApplicationCall
import io.ktor.request.header
import io.ktor.request.receive
import io.ktor.util.AttributeKey
import io.ktor.util.Attributes

// All these functions have been extracted from the file SwaggerUtils.kt in package io.ktor.swagger.experimental
// which is generated by the ktor starter.

enum class Source {
    BODY, QUERY, FORM_DATA, HEADER, PATH
}

object Json {
    @PublishedApi
    internal val objectMapper = jacksonObjectMapper()

    fun <T> convert(value: Any?, clazz: Class<T>): T = objectMapper.convertValue(value, clazz)
    fun <T> parse(str: String, clazz: Class<T>): T = objectMapper.readValue(str, clazz)
    fun <T> stringify(value: T): String = objectMapper.writeValueAsString(value)
}

suspend fun <T> ApplicationCall.getTyped(source: Source, name: String, clazz: Class<T>): T {
    return Json.convert(getRaw(source, name), clazz)
}

suspend fun <T> ApplicationCall.getTypedOrNull(source: Source, name: String, clazz: Class<T>): T? =
    getRaw(source, name)?.let { Json.convert(it, clazz) }

suspend fun ApplicationCall.getRaw(source: Source, name: String): Any? {
    return when (source) {
        Source.PATH -> this.parameters.get(name)
        Source.QUERY -> this.request.queryParameters.get(name)
        Source.BODY -> this.getCachedUntypedBody()[name]
        Source.FORM_DATA -> TODO()
        Source.HEADER -> this.request.header(name)
    }
}

suspend inline fun <reified T : Any> ApplicationCall.getBodyParam(name: String, noinline default: () -> T = { error("mandatory $name") }): T =
    getTypedOrNull(Source.BODY, name, T::class.java) ?: default()

suspend inline fun <reified T : Any> ApplicationCall.getPath(name: String, noinline default: () -> T = { error("mandatory $name") }): T =
    getTypedOrNull(Source.PATH, name, T::class.java) ?: default()

suspend inline fun <reified T : Any> ApplicationCall.getQuery(name: String, noinline default: () -> T = { error("mandatory $name") }): T =
    getTypedOrNull(Source.QUERY, name, T::class.java) ?: default()

inline fun <T : Any> Attributes.computeIfAbsentInline(key: AttributeKey<T>, block: () -> T): T {
    if (!this.contains(key)) {
        this.put(key, block())
    }
    return this[key]
}

private suspend fun ApplicationCall.getCachedUntypedBody(): Map<String, Any?> {
    return attributes.computeIfAbsentInline(CACHED_BODY_KEY) {
        Json.parse(this@getCachedUntypedBody.receive(), HashMap::class.java)
    } as Map<String, Any?>
}

val CACHED_BODY_KEY = AttributeKey<Any>("CACHED_BODY_KEY")
