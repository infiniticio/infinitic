/**
 * "Commons Clause" License Condition v1.0
 *
 * The Software is provided to you by the Licensor under the License, as defined below, subject to
 * the following condition.
 *
 * Without limiting other conditions in the License, the grant of rights under the License will not
 * include, and the License does not grant to you, the right to Sell the Software.
 *
 * For purposes of the foregoing, “Sell” means practicing any or all of the rights granted to you
 * under the License to provide to third parties, for a fee or other consideration (including
 * without limitation fees for hosting or consulting/ support services related to the Software), a
 * product or service whose value derives, entirely or substantially, from the functionality of the
 * Software. Any license notice or attribution required by the License must also include this
 * Commons Clause License Condition notice.
 *
 * Software: Infinitic
 *
 * License: MIT License (https://opensource.org/licenses/MIT)
 *
 * Licensor: infinitic.io
 */
package io.infinitic.common.workers.registry

import io.infinitic.common.exceptions.thisShouldNotHappen
import io.infinitic.common.workers.config.WorkflowVersion
import io.infinitic.common.workflows.WorkflowContext
import io.infinitic.common.workflows.data.workflowTasks.WorkflowTaskParameters
import io.infinitic.common.workflows.data.workflows.WorkflowName
import io.infinitic.common.workflows.emptyWorkflowContext
import io.infinitic.exceptions.workflows.UnknownWorkflowVersionException
import io.infinitic.tasks.WithRetry
import io.infinitic.tasks.WithTimeout
import io.infinitic.workflows.Workflow
import io.infinitic.workflows.WorkflowCheckMode

typealias WorkflowFactories = List<() -> Workflow>
typealias WorkflowFactory = () -> Workflow

data class RegisteredWorkflowExecutor(
  val workflowName: WorkflowName,
  val factories: WorkflowFactories,
  val concurrency: Int,
  val withTimeout: WithTimeout?,
  val withRetry: WithRetry?,
  val checkMode: WorkflowCheckMode?
) {
  private var classFactoryInstanceByVersion: Map<WorkflowVersion, Triple<Class<out Workflow>, WorkflowFactory, Workflow>>

  var classes: List<Class<out Workflow>>

  init {
    require(factories.isNotEmpty()) { "List of factory must not be empty for workflow '$workflowName'" }

    // this is needed in case the workflow properties use the workflow context
    Workflow.setContext(emptyWorkflowContext)
    // store the list of classes generated by `factories`.
    classes = factories.mapIndexed { index, factory ->
      try {
        factory()::class.java
      } catch (e: Exception) {
        throw IllegalArgumentException(
            "Error in factory #$index while registering workflow $workflowName",
            e,
        )
      }
    }

    // check that each class is associated with a different version
    val classVersionMap = classes.associateWith { WorkflowVersion.from(it) }
    classVersionMap.values
        .groupingBy { it }
        .eachCount()
        .filter { it.value > 1 }
        .keys
        .forEach { version ->
          val list = classVersionMap.filter { version == it.value }.keys.joinToString { it.name }

          throw IllegalArgumentException(
              "$list have same version $version for workflow $workflowName",
          )
        }

    val instances = factories.map { it() }

    // for each version, we store the Triple<Class<out Workflow, Instance>, () -> Workflow>
    classFactoryInstanceByVersion = classes.mapIndexed { index, item ->
      Triple(item, factories[index], instances[index])
    }.associateBy { WorkflowVersion.from(it.first) }
  }

  private val lastVersion by lazy {
    classFactoryInstanceByVersion.keys.maxOrNull() ?: thisShouldNotHappen()
  }

  fun getInstance(workflowTaskParameters: WorkflowTaskParameters): Workflow =
      with(workflowTaskParameters) {
        // set WorkflowContext before Workflow instance creation
        Workflow.setContext(
            WorkflowContext(
                workflowName = workflowName.toString(),
                workflowId = workflowId.toString(),
                methodName = workflowMethod.methodName.toString(),
                methodId = workflowMethod.workflowMethodId.toString(),
                meta = workflowMeta.map,
                tags = workflowTags.map { it.tag }.toSet(),
            ),
        )

        getInstanceByVersion(workflowVersion)
      }

  fun getInstanceByVersion(workflowVersion: WorkflowVersion?): Workflow {
    val (klass, factory, instance) = getClassFactoryByVersion(workflowVersion)
    return factory().also {
      // checking that the factory does not create an instance whose class is different from the initial call
      if (!klass.isInstance(it)) throw IllegalArgumentException(
          "The workflow factory has generated an instance of the class ${it::class}, " +
              "which does not match the expected class $klass. Check your workflow factory implementation.",
      )
      // checking that the instance created is different from the initial instance created
      if (it === instance) throw IllegalArgumentException(
          "The workflow factory has returned the same object instance ($it) twice. " +
              "It should always return a new object instance when called. Check your workflow factory implementation.",
      )
    }
  }

  private fun getClassFactoryByVersion(workflowVersion: WorkflowVersion?): Triple<Class<out Workflow>, () -> Workflow, Workflow> {
    val version = workflowVersion ?: lastVersion

    return classFactoryInstanceByVersion[version] ?: throw UnknownWorkflowVersionException(
        workflowName,
        version,
    )
  }
}
